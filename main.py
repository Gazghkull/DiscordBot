import discord
from discord.ext import commands
from discord import app_commands
from typing import Optional, Tuple, List
import os
from dotenv import load_dotenv
import json
import threading
import time
import random
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

load_dotenv()

# ----------------- FACTIONS -----------------
FACTIONS = ["Envahisseur", "D√©fenseur", "Pirate"]

# ----------------- PLANETES & SYSTEMS -----------------
def create_planet_stats():
    return {f: {"points": 0, "batailles": 0, "choix": 0} for f in FACTIONS}

# Exemple par d√©faut pour SYSTEMS
SYSTEMS = {
    "Memlock": {
        "Iliar II": create_planet_stats(),
        "Memlock": create_planet_stats(),
        "Udesore": create_planet_stats(),
        "Station Ivius": create_planet_stats(),
        "Telock": create_planet_stats()
    }
    # Les autres syst√®mes seront ajout√©s par la suite
}

# R√®gles pour chaque syst√®me : PV et bonus syst√®me
SYSTEM_RULES = {
    "Memlock": {
        "pv_thresholds": [2, 5],  # PV √† 2 et 5 points
        "bonus_threshold": 3,     # Bonus syst√®me au-dessus de 3 points
        "planets": {
            "Iliar II": 1,
            "Memlock": 2,
            "Udesore": 1,
            "Station Ivius": 1,
            "Telock": 2
        }
    },
    "Hovot": {
        "pv_thresholds": [2, 5],
        "bonus_threshold": 3,
        "planets": {
            "Maben": 1,
            "Vivim": 1,
            "Station d'ancrage des Navigateurs de l'Obscure": 2,
            "Hebda": 1
        }
    },
    "Acraelon": {
        "pv_thresholds": [2, 5],
        "bonus_threshold": 3,
        "planets": {
            "Meggdal": 2,
            "Sumemnal": 1,
            "Station B√©n√©diction du champ Gleecer": 2,
            "Arrabal": 2,
            "Maeron": 1
        }
    },
    "Umnal": {
        "pv_thresholds": [2],
        "bonus_threshold": 3,
        "planets": {
            "Takfor": 2,
            "Umnal Silva": 1,
            "Umnalis": 1
        }
    },
    "Makravor": {
        "pv_thresholds": [3, 6],
        "bonus_threshold": 4,
        "planets": {
            "Atar Oblitus": 1,
            "Atar Secundus": 2,
            "Atar Prime": 1,
            "Twi‚Äôtai": 2,
            "Makravor": 2,
            "Vint": 1
        }
    },
    "Arar": {
        "pv_thresholds": [2],
        "bonus_threshold": 3,
        "planets": {
            "Arar I": 1,
            "Berlag": 2
        }
    }
}

# ----------------- PHASES -----------------
CURRENT_PHASE = 1  # Phase en cours
TOTAL_PARTIES = {f: 0 for f in FACTIONS}  # Batailles phase en cours
PHASES_HISTORY = {}  # Historique des phases : PV et bonus syst√®me
DATA_FILE = "data.json"

# ----------------- HONNEUR FORUM IDS -----------------
FORUM_IDS = [1424007352348049598, 1424806344417873960]

HonneurKeyWords = []

ACTIVE_SYSTEMS = {system: True for system in SYSTEM_RULES.keys()}
# ----------------- LOAD/SAVE DATA -----------------
def load_data():
    global SYSTEMS, SYSTEM_RULES, ACTIVE_SYSTEMS, CURRENT_PHASE, TOTAL_PARTIES, PHASES_HISTORY, HonneurKeyWords
    try:
        with open(DATA_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
            SYSTEMS = data.get("systems", SYSTEMS)
            SYSTEM_RULES = data.get("system_rules", SYSTEM_RULES)
            ACTIVE_SYSTEMS = data.get("active_systems", {s: True for s in SYSTEM_RULES.keys()})
            CURRENT_PHASE = data.get("current_phase", 1)
            TOTAL_PARTIES = data.get("total_parties", {f: 0 for f in FACTIONS})
            PHASES_HISTORY = data.get("phases_history", {})
            HonneurKeyWords = data.get("HonneurKeyWords", [])
            print("‚úÖ Donn√©es charg√©es depuis data.json")
    except FileNotFoundError:
        print("‚ö†Ô∏è data.json introuvable, cr√©ation du fichier par d√©faut")
        save_data()
    except Exception as e:
        print(f"‚ùå Erreur lors du chargement des donn√©es : {e}")

def save_data():
    try:
        with open(DATA_FILE, "w", encoding="utf-8") as f:
            json.dump({
                "systems": SYSTEMS,
                "system_rules": SYSTEM_RULES,
                "active_systems": ACTIVE_SYSTEMS,
                "current_phase": CURRENT_PHASE,
                "total_parties": TOTAL_PARTIES,
                "phases_history": PHASES_HISTORY,
                "HonneurKeyWords": HonneurKeyWords
            }, f, indent=4, ensure_ascii=False)
            print("üíæ Donn√©es sauvegard√©es dans data.json")
    except Exception as e:
        print(f"‚ùå Erreur lors de la sauvegarde des donn√©es : {e}")

# ----------------- CONFIG -----------------
GUILD_ID = 1384163146050048092
guild = discord.Object(id=GUILD_ID)

intents = discord.Intents.default()
bot = commands.Bot(command_prefix="!", intents=intents)
load_data()
tree = bot.tree

# ----------------- SURVEILLANCE DATA -----------------
class DataFileHandler(FileSystemEventHandler):
    def __init__(self, file_path, callback):
        self.file_path = file_path
        self.callback = callback
    def on_modified(self, event):
        if event.src_path.endswith(self.file_path):
            print(f"üîÑ {self.file_path} modifi√©, rechargement des donn√©es...")
            self.callback()

def start_data_watch(file_path: str, callback):
    event_handler = DataFileHandler(file_path, callback)
    observer = Observer()
    observer.schedule(event_handler, ".", recursive=False)
    observer.start()
    def keep_alive():
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            observer.stop()
        observer.join()
    threading.Thread(target=keep_alive, daemon=True).start()

# ----------------- UTILITAIRES -----------------
def find_planet(planet_name: str) -> Optional[Tuple[str, str]]:
    for systeme, planets in SYSTEMS.items():
        if planet_name in planets:
            return systeme, planet_name
    return None

def all_planets() -> List[str]:
    return [p for planets in SYSTEMS.values() for p in planets.keys()]

# ----------------- CALCUL PV ET BONUS -----------------
def calculate_system_scores(systeme: str, phase: Optional[int] = None):
    """
    Retourne pour le syst√®me donn√© :
        pv_scores : {faction: nb de PV acquis en phase pr√©c√©dente ou avancement}
        bonus_owner : faction ou None
    """
    rules = SYSTEM_RULES[systeme]
    planets_values = rules["planets"]
    pv_thresholds = rules["pv_thresholds"]
    bonus_threshold = rules["bonus_threshold"]

    # Somme des points de chaque faction
    faction_points = {f: 0 for f in FACTIONS}
    for planet, value in planets_values.items():
        for f in FACTIONS:
            faction_points[f] += SYSTEMS[systeme][planet][f]["points"]

    # Calcul des PV
    pv_scores = {f: 0 for f in FACTIONS}
    for threshold in pv_thresholds:
        for f in FACTIONS:
            if faction_points[f] >= threshold:
                pv_scores[f] += 1

    # Bonus syst√®me : seulement la faction la plus haute, sauf √©galit√©
    max_pts = max(faction_points.values())
    owners = [f for f, pts in faction_points.items() if pts == max_pts and pts >= bonus_threshold]
    bonus_owner = owners[0] if len(owners) == 1 else None

    # Si phase pass√©e, prendre PV/bonus du PHASES_HISTORY
    if phase is not None and phase in PHASES_HISTORY:
        phase_data = PHASES_HISTORY[phase].get("systems_scores", {})
        pv_scores = phase_data.get("pv_scores", pv_scores)
        bonus_owner = phase_data.get("bonus_owner", bonus_owner)

    return pv_scores, bonus_owner


# ----------------- AUTOCOMPLETION -----------------
async def autocomplete_planete(interaction: discord.Interaction, current: str):
  return [
      app_commands.Choice(name=p, value=p) for p in all_planets()
      if current.lower() in p.lower()
  ][:25]


async def autocomplete_faction(interaction: discord.Interaction, current: str):
  return [
      app_commands.Choice(name=f, value=f) for f in FACTIONS
      if current.lower() in f.lower()
  ][:25]


async def autocomplete_numbers(interaction: discord.Interaction, current: str):
  numbers = [str(i) for i in range(0, 21)]
  return [
      app_commands.Choice(name=n, value=n) for n in numbers if current in n
  ][:25]


async def autocomplete_systeme(interaction: discord.Interaction, current: str):
  return [
      app_commands.Choice(name=s, value=s) for s in SYSTEMS.keys()
      if current.lower() in s.lower()
  ][:25]


async def autocomplete_phase(interaction: discord.Interaction, current: str):
  phases = [str(i) for i in range(1, CURRENT_PHASE + 1)]
  return [
      app_commands.Choice(name=p, value=p) for p in phases if current in p
  ][:25]

async def autocomplete_honneur(interaction: discord.Interaction, current: str):
    return [
        app_commands.Choice(name=kw, value=kw)
        for kw in HonneurKeyWords
        if current.lower() in kw.lower()
    ][:25]

# ----------------- COMMANDES -----------------
@tree.command(name="ajout",
              description="Ajouter une partie/bataille",
              guild=guild)
@app_commands.describe(
    planete="Nom de la plan√®te",
    gagnant="Faction gagnante ou 'Egalite'",
    choix_planete="Faction qui a choisi la plan√®te",
    participant1="Premier participant",
    participant2="Deuxi√®me participant",
    participant3="Troisi√®me participant (facultatif)",
    phase="Phase dans laquelle ajouter la partie (optionnel)")
@app_commands.autocomplete(planete=autocomplete_planete,
                           gagnant=autocomplete_faction,
                           choix_planete=autocomplete_faction,
                           participant1=autocomplete_faction,
                           participant2=autocomplete_faction,
                           participant3=autocomplete_faction,
                           phase=autocomplete_phase)
async def ajout(interaction: discord.Interaction,
                         planete: str,
                         gagnant: str,
                         choix_planete: str,
                         participant1: str,
                         participant2: str,
                         participant3: Optional[str] = None,
                         phase: Optional[int] = None):
  global CURRENT_PHASE, TOTAL_PARTIES, PHASES_HISTORY

  participants_list = [
      p for p in [participant1, participant2, participant3] if p
  ]
  planet_info = find_planet(planete)
  if planet_info is None:
    await interaction.response.send_message(f"‚ùå Plan√®te inconnue : {planete}",
                                            ephemeral=True)
    return
  systeme, planete_found = planet_info

  gagnant = gagnant.capitalize()
  choix_planete = choix_planete.capitalize()

  # Validation participants
  for f in participants_list:
    if f not in FACTIONS:
      await interaction.response.send_message(f"‚ùå Faction inconnue : {f}",
                                              ephemeral=True)
      return
  if gagnant != "Egalite" and gagnant not in participants_list:
    await interaction.response.send_message(
        "‚ùå Le gagnant doit √™tre parmi les participants ou 'Egalite'",
        ephemeral=True)
    return
  if choix_planete not in participants_list:
    await interaction.response.send_message(
        "‚ùå La faction qui choisit la plan√®te doit √™tre parmi les participants",
        ephemeral=True)
    return

  # D√©terminer la phase
  target_phase = phase if phase is not None else CURRENT_PHASE

  # Si on ajoute dans la phase en cours, on incr√©mente TOTAL_PARTIES
  if target_phase == CURRENT_PHASE:
    for f in participants_list:
      TOTAL_PARTIES[f] += 1

  # Attribution des points et choix pour la plan√®te
  for f in participants_list:
    # Points (conserv√©s entre les phases)
    if f == gagnant:
      SYSTEMS[systeme][planete_found][f]["points"] += 3
    elif gagnant == "Egalite":
      SYSTEMS[systeme][planete_found][f]["points"] += 2
    else:
      SYSTEMS[systeme][planete_found][f]["points"] += 1

    # Batailles & choix (par phase)
    if target_phase == CURRENT_PHASE:
      SYSTEMS[systeme][planete_found][f]["batailles"] += 1
      if f == choix_planete:
        SYSTEMS[systeme][planete_found][f]["choix"] += 1
    else:
      # Si ajout dans une phase ant√©rieure
      if target_phase not in PHASES_HISTORY:
        PHASES_HISTORY[target_phase] = {
            "total_parties": {
                f: 0
                for f in FACTIONS
            },
            "choix_planete": {
                f: 0
                for f in FACTIONS
            }
        }
      PHASES_HISTORY[target_phase]["total_parties"][f] += 1
      if f == choix_planete:
        PHASES_HISTORY[target_phase]["choix_planete"][f] += 1

  await interaction.response.send_message(
      f"‚úÖ Partie ajout√©e sur **{planete_found} ({systeme})** dans la phase {target_phase} !\n"
      f"Gagnant : **{gagnant}**, choix de la plan√®te : **{choix_planete}**, participants : {', '.join(participants_list)}"
  )
  save_data()


# ----------------- Cl√¥turer phase -----------------
@tree.command(name="cloture",
              description="Cl√¥turer la phase en cours",
              guild=guild)
async def cloture(interaction: discord.Interaction):
  global CURRENT_PHASE, TOTAL_PARTIES, PHASES_HISTORY

  # Sauvegarder stats de la phase
  phase_data = {
      "total_parties": TOTAL_PARTIES.copy(),
      "choix_planete": {
          f: 0
          for f in FACTIONS
      }
  }
  for systeme, planets in SYSTEMS.items():
    for planet, data in planets.items():
      for f, stats in data.items():
        phase_data["choix_planete"][f] += stats["choix"]

  PHASES_HISTORY[CURRENT_PHASE] = phase_data

  # R√©initialiser compteurs de la phase
  TOTAL_PARTIES = {f: 0 for f in FACTIONS}
  for systeme, planets in SYSTEMS.items():
    for planet, data in planets.items():
      for f in data:
        data[f]["batailles"] = 0
        data[f]["choix"] = 0

  CURRENT_PHASE += 1

  await interaction.response.send_message(
      f"‚úÖ Phase {CURRENT_PHASE - 1} cl√¥tur√©e ! Passage √† la phase {CURRENT_PHASE}."
  )
  save_data()


# ----------------- Commande phase actuelle -----------------
@tree.command(name="phase",
              description="Afficher la phase en cours",
              guild=guild)
async def phase(interaction: discord.Interaction):
  await interaction.response.send_message(
      f"üìå Phase actuelle : **{CURRENT_PHASE}**")


# ----------------- Commande stats phase -----------------
@tree.command(name="phase_stats",
              description="Afficher les stats d'une phase pr√©c√©dente",
              guild=guild)
@app_commands.describe(phase="Num√©ro de la phase")
@app_commands.autocomplete(phase=autocomplete_phase)
async def phase_stats(interaction: discord.Interaction, phase: int):
  if phase not in PHASES_HISTORY:
    await interaction.response.send_message(f"‚ùå Phase {phase} inconnue",
                                            ephemeral=True)
    return

  data = PHASES_HISTORY[phase]
  embed = discord.Embed(title=f"üìä Stats Phase {phase}",
                        color=discord.Color.blue())

  for f in FACTIONS:
    total_parties = data["total_parties"].get(f, 0)
    choix_planete = data["choix_planete"].get(f, 0)
    embed.add_field(
        name=f,
        value=
        f"Parties disput√©es : {total_parties}\nChoix de plan√®te : {choix_planete}",
        inline=False)

  await interaction.response.send_message(embed=embed)


# ----------------- STATS PLANETE -----------------
@tree.command(name="planete",
              description="Afficher les stats d‚Äôune plan√®te",
              guild=guild)
@app_commands.describe(planete="Nom de la plan√®te")
@app_commands.autocomplete(planete=autocomplete_planete)
async def planete(interaction: discord.Interaction, planete: str):
    planet_info = find_planet(planete)
    if planet_info is None:
        await interaction.response.send_message(f"‚ùå Plan√®te inconnue : {planete}",
                                                ephemeral=True)
        return
    systeme, planete_found = planet_info

    embed = discord.Embed(title=f"ü™ê {systeme.upper()}",
                          color=discord.Color.green())

    ICONS = {
        "D√©fenseur": "üõ°Ô∏è",
        "Envahisseur": "‚öîÔ∏è",
        "Pirate": "üíÄ"
    }

    value = f"‚ñ™Ô∏è\u2003üåè **{planete_found}**\n"

    # R√©cup√®re les points pour chaque faction
    scores = {f: SYSTEMS[systeme][planete_found][f]["points"] for f in FACTIONS}
    max_score = max(scores.values())
    leaders = [f for f, pts in scores.items() if pts == max_score and pts > 0]

    # Ordre forc√© D√©fenseur ‚Üí Envahisseur ‚Üí Pirate
    for f in ["D√©fenseur", "Envahisseur", "Pirate"]:
        v = SYSTEMS[systeme][planete_found][f]
        suffix = ""
        if f in leaders:
            if len(leaders) == 1:
                suffix = " ‚û°Ô∏è"
            else:
                suffix = " ‚öñÔ∏è"

        # Affichage : ic√¥ne + suffixe + nom de la faction
        value += f"‚ñ™Ô∏è\u2003 \u2003{ICONS.get(f,'')}{suffix} {f} : **{v['points']} pts** | `{v['batailles']} batailles`\n"

    embed.add_field(name="", value=value, inline=False)
    await interaction.response.send_message(embed=embed)


# ----------------- AUTRES COMMANDES -----------------
@tree.command(
    name="faction",
    description="Afficher les statistiques d‚Äôune faction pr√©cise",
    guild=guild
)
@app_commands.describe(faction="Nom de la faction (D√©fenseur, Envahisseur, Pirate)")
@app_commands.choices(faction=[
    app_commands.Choice(name="D√©fenseur", value="D√©fenseur"),
    app_commands.Choice(name="Envahisseur", value="Envahisseur"),
    app_commands.Choice(name="Pirate", value="Pirate")
])
async def faction(interaction: discord.Interaction, faction: app_commands.Choice[str]):
    faction_nom = faction.value
    total_points = 0
    total_batailles = 0
    plan√®tes_gagn√©es = 0
    syst√®mes_domines = {}

    # --- Analyse de chaque plan√®te ---
    for systeme, planets in SYSTEMS.items():
        system_points = 0
        for planete, data in planets.items():
            pts = data[faction_nom]["points"]
            total_points += pts
            total_batailles += data[faction_nom]["batailles"]

            # Leader unique sur cette plan√®te ?
            max_points = max(fdata["points"] for fdata in data.values())
            leaders = [f for f, fdata in data.items() if fdata["points"] == max_points]
            if len(leaders) == 1 and leaders[0] == faction_nom:
                plan√®tes_gagn√©es += 1
                system_points += 1

        if system_points > 0:
            syst√®mes_domines[systeme] = system_points

    embed = discord.Embed(
        title=f"üè≥Ô∏è {faction_nom} ‚Äì Rapport strat√©gique",
        color=discord.Color.blue() if faction_nom == "D√©fenseur"
        else discord.Color.red() if faction_nom == "Envahisseur"
        else discord.Color.dark_gold()
    )

    embed.add_field(name="üî¢ Points totaux", value=f"**{total_points}**", inline=True)
    embed.add_field(name="‚öîÔ∏è Batailles livr√©es", value=f"**{total_batailles}**", inline=True)
    embed.add_field(name="üèÜ Plan√®tes contr√¥l√©es", value=f"**{plan√®tes_gagn√©es}**", inline=True)

    if syst√®mes_domines:
        desc = "\n".join([f"‚Ä¢ {sys} ({pts} plan√®tes gagn√©es)" for sys, pts in syst√®mes_domines.items()])
    else:
        desc = "Aucun syst√®me domin√© actuellement."

    embed.add_field(name="üåå Influence par syst√®me", value=desc, inline=False)
    embed.set_footer(text="Les chiffres sont mis √† jour automatiquement apr√®s chaque bataille.")
    await interaction.response.send_message(embed=embed)

# ----------------- SYSTEMES -----------------
@tree.command(name="liste_sys",
              description="Afficher la liste des syst√®mes et leurs plan√®tes",
              guild=guild)
async def liste_sys(interaction: discord.Interaction):
  desc = ""
  for systeme, planets in SYSTEMS.items():
    desc += f"**{systeme}** : {', '.join(planets.keys())}\n"
  await interaction.response.send_message(f"üìú Syst√®mes et plan√®tes :\n{desc}")


# ----------------- STATS SYSTEME -----------------
@tree.command(
    name="systeme",
    description="Afficher les stats d‚Äôun syst√®me pr√©cis avec toutes ses plan√®tes",
    guild=guild
)
@app_commands.describe(systeme="Nom du syst√®me")
@app_commands.autocomplete(systeme=autocomplete_systeme)
async def systeme(interaction: discord.Interaction, systeme: str):
    systeme = systeme.capitalize()
    if systeme not in SYSTEMS:
        await interaction.response.send_message(
            f"‚ùå Syst√®me inconnu : {systeme}", ephemeral=True
        )
        return

    embed = discord.Embed(title=f"ü™ê {systeme.upper()}", color=discord.Color.green())

    ICONS = {
        "D√©fenseur": "üõ°Ô∏è",
        "Envahisseur": "‚öîÔ∏è",
        "Pirate": "üíÄ"
    }

    CASE_EMPTY = "‚ñ´Ô∏è"
    CASE_PV = "üèÖ"
    CASE_BONUS = "üö©"
    SPACE = "‚ÄÉ"

    rules = SYSTEM_RULES.get(systeme, {})
    pv_thresholds = rules.get("pv_thresholds", [5])
    bonus_threshold = rules.get("bonus_threshold", 3)
    planet_values = rules.get("planets", {})

    max_points = max(pv_thresholds + [bonus_threshold])

    # --- Calcul de l'avancement ---
    total_pv = {f: 0 for f in ICONS.keys()}
    for planet, data in SYSTEMS[systeme].items():
        if planet not in planet_values:
            continue
        scores = {f: data[f]["points"] for f in ICONS.keys()}
        max_score = max(scores.values())
        if max_score <= 0:
            continue
        leaders = [f for f, pts in scores.items() if pts == max_score]
        if len(leaders) == 1:
            gagnant = leaders[0]
            total_pv[gagnant] += planet_values[planet]

    # --- Tableau d‚Äôavancement ---
    alignment_prefix = " " * len(f"{ICONS['D√©fenseur']} :‚ÄÉ")
    line_avancement = alignment_prefix + CASE_EMPTY + SPACE
    for pos in range(1, max_points + 1):
        if pos in pv_thresholds:
            line_avancement += CASE_PV + SPACE
        elif pos == bonus_threshold:
            line_avancement += CASE_BONUS + SPACE
        else:
            line_avancement += CASE_EMPTY + SPACE

    faction_lines = []
    for f, pts in total_pv.items():
        pos_line = [CASE_EMPTY] * (max_points + 1)
        pos_index = min(max(pts, 0), max_points)
        pos_line[pos_index] = ICONS[f]
        faction_lines.append(SPACE.join(pos_line))

    # --- Ajoute l‚Äôavancement juste apr√®s le nom du syst√®me ---
    avancement_block = "**Avancement :**\n" + line_avancement.strip() + "\n" + "\n".join(faction_lines)
    embed.add_field(name="", value=avancement_block, inline=False)

    # --- D√©tails des plan√®tes ---
    lines = []
    for planet, data in SYSTEMS[systeme].items():
        lines.append(f"‚ñ™Ô∏è‚ÄÉüåè **{planet}**")
        scores = {f: data[f]["points"] for f in ["D√©fenseur", "Envahisseur", "Pirate"]}
        max_score = max(scores.values())
        leaders = [f for f, pts in scores.items() if pts == max_score and pts > 0]

        for f in ["D√©fenseur", "Envahisseur", "Pirate"]:
            v = data[f]
            suffix = ""
            if f in leaders:
                suffix = " üèÜ" if len(leaders) == 1 else " ‚öñÔ∏è"
            lines.append(f"‚ñ™Ô∏è‚ÄÉ‚ÄÉ{ICONS[f]}{suffix} {f} : **{v['points']} pts** | `{v['batailles']} batailles`")
        lines.append("")  # ligne vide entre plan√®tes

    # --- D√©coupage en chunks s√ªrs ---
    MAX_FIELD_LEN = 1000
    chunks = []
    current = ""
    for ln in lines:
        if len(current) + len(ln) + 1 > MAX_FIELD_LEN:
            chunks.append(current.rstrip("\n"))
            current = ""
        current += ln + "\n"
    if current:
        chunks.append(current.rstrip("\n"))

    for chunk in chunks:
        embed.add_field(name="", value=chunk, inline=False)

    await interaction.response.send_message(embed=embed)

# ----------------- STATS TOUT -----------------
@tree.command(
    name="stats",
    description="Afficher les stats de toutes les plan√®tes des syst√®mes actifs",
    guild=guild
)
async def stats(interaction: discord.Interaction):
    embed = discord.Embed(
        title="‚öîÔ∏è Statistiques des syst√®mes actifs",
        color=discord.Color.green()
    )

    ICONS = {
        "D√©fenseur": "üõ°Ô∏è",
        "Envahisseur": "‚öîÔ∏è",
        "Pirate": "üíÄ"
    }

    CASE_EMPTY = "‚ñ´Ô∏è"
    CASE_PV = "üèÖ"
    CASE_BONUS = "üö©"
    SPACE = "‚ÄÉ"

    systems_displayed = 0
    MAX_FIELD_LEN = 1000
    MAX_FIELDS = 25

    active_systems = [s for s in SYSTEMS if ACTIVE_SYSTEMS.get(s, True)]

    for idx, systeme in enumerate(active_systems):
        # --- Ajoute une ligne de s√©paration avant ce syst√®me sauf pour le premier ---
        if idx > 0:
            if len(embed.fields) < MAX_FIELDS:
                embed.add_field(name="", value="‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï", inline=False)

        rules = SYSTEM_RULES.get(systeme, {})
        pv_thresholds = rules.get("pv_thresholds", [5])
        bonus_threshold = rules.get("bonus_threshold", 3)
        planet_values = rules.get("planets", {})
        max_points = max(pv_thresholds + [bonus_threshold])

        # --- Calcul de l'avancement du syst√®me ---
        total_pv = {f: 0 for f in ICONS.keys()}
        for planet, data in SYSTEMS[systeme].items():
            if planet not in planet_values:
                continue
            scores = {f: data[f]["points"] for f in ICONS.keys()}
            max_score = max(scores.values())
            if max_score <= 0:
                continue
            leaders = [f for f, pts in scores.items() if pts == max_score]
            if len(leaders) == 1:
                gagnant = leaders[0]
                total_pv[gagnant] += planet_values[planet]

        # --- Ligne principale d‚Äôavancement ---
        alignment_prefix = " " * len(f"{ICONS['D√©fenseur']} :‚ÄÉ")
        line_avancement = alignment_prefix + CASE_EMPTY + SPACE
        for pos in range(1, max_points + 1):
            if pos in pv_thresholds:
                line_avancement += CASE_PV + SPACE
            elif pos == bonus_threshold:
                line_avancement += CASE_BONUS + SPACE
            else:
                line_avancement += CASE_EMPTY + SPACE

        # Lignes factions
        faction_lines = []
        for f, pts in total_pv.items():
            pos_line = [CASE_EMPTY] * (max_points + 1)
            pos_index = min(max(pts, 0), max_points)
            pos_line[pos_index] = ICONS[f]
            faction_lines.append(SPACE.join(pos_line))

        # --- On ajoute le tableau d‚Äôavancement juste apr√®s le nom du syst√®me ---
        avancement_block = "**Avancement :**\n" + line_avancement.strip() + "\n" + "\n".join(faction_lines)
        field_name = f"ü™ê {systeme.upper()}"
        if len(embed.fields) < MAX_FIELDS:
            embed.add_field(name=field_name, value=avancement_block, inline=False)
            systems_displayed += 1

        # --- Pr√©pare les lignes pour les plan√®tes ---
        planet_lines = []
        for planet, data in SYSTEMS[systeme].items():
            planet_lines.append(f"‚ñ™Ô∏è‚ÄÉüåè **{planet}**")
            scores = {f: data[f]["points"] for f in data.keys()}
            max_score = max(scores.values())
            leaders = [f for f, pts in scores.items() if pts == max_score and pts > 0]

            for f in ["D√©fenseur", "Envahisseur", "Pirate"]:
                v = data[f]
                suffix = ""
                if f in leaders:
                    suffix = " üèÜ" if len(leaders) == 1 else " ‚öñÔ∏è"
                planet_lines.append(f"‚ñ™Ô∏è‚ÄÉ‚ÄÉ{ICONS[f]}{suffix} {f} : **{v['points']} pts** | `{v['batailles']} batailles`")
            planet_lines.append("")

        # --- D√©coupe en chunks et ajout dans l'embed ---
        chunks = []
        current = ""
        for ln in planet_lines:
            if len(current) + len(ln) + 1 > MAX_FIELD_LEN:
                chunks.append(current.rstrip("\n"))
                current = ""
            current += ln + "\n"
        if current:
            chunks.append(current.rstrip("\n"))

        for chunk in chunks:
            if len(embed.fields) < MAX_FIELDS:
                embed.add_field(name="", value=chunk, inline=False)

    if systems_displayed == 0:
        embed.description = "‚ùå Aucun syst√®me actif pour cette phase."

    await interaction.response.send_message(embed=embed)
# ----------------- MODIFIER STATS -----------------
@tree.command(
    name="modif",
    description=
    "Modifier directement les points ou batailles d‚Äôune faction sur une plan√®te",
    guild=guild)
@app_commands.describe(planete="Nom de la plan√®te",
                       faction="Faction √† modifier",
                       points="Points de victoire (optionnel, 0-20)",
                       batailles="Nombre de batailles (optionnel, 0-20)")
@app_commands.autocomplete(planete=autocomplete_planete,
                           faction=autocomplete_faction,
                           points=autocomplete_numbers,
                           batailles=autocomplete_numbers)
async def modif(interaction: discord.Interaction,
                         planete: str,
                         faction: str,
                         points: Optional[int] = None,
                         batailles: Optional[int] = None):
  faction = faction.capitalize()
  planet_info = find_planet(planete)
  if planet_info is None:
    await interaction.response.send_message(f"‚ùå Plan√®te inconnue : {planete}",
                                            ephemeral=True)
    return

  systeme_found, planete_found = planet_info
  if faction not in FACTIONS:
    await interaction.response.send_message(f"‚ùå Faction inconnue : {faction}",
                                            ephemeral=True)
    return

  # Mise √† jour des stats
  if points is not None:
    SYSTEMS[systeme_found][planete_found][faction]["points"] = points

  if batailles is not None:
    delta = batailles - SYSTEMS[systeme_found][planete_found][faction][
        "batailles"]
    SYSTEMS[systeme_found][planete_found][faction]["batailles"] = batailles
    TOTAL_PARTIES[faction] += delta

  await interaction.response.send_message(
      f"‚úÖ Stats modifi√©es pour **{faction}** sur **{planete_found}** ({systeme_found}) : points={points} batailles={batailles}"
  )
  save_data()


# ----------------- AJOUTER SYSTEME -----------------
@tree.command(
    name="ajout_sys",
    description="Ajouter un nouveau syst√®me avec au moins une plan√®te",
    guild=guild)
@app_commands.describe(
    systeme="Nom du syst√®me √† cr√©er",
    premiere_planete="Nom de la premi√®re plan√®te du syst√®me")
async def ajout_sys(interaction: discord.Interaction, systeme: str,
                          premiere_planete: str):
  systeme = systeme.capitalize()
  premiere_planete = premiere_planete.capitalize()

  if systeme in SYSTEMS:
    await interaction.response.send_message(
        f"‚ùå Le syst√®me **{systeme}** existe d√©j√† !", ephemeral=True)
    return

  SYSTEMS[systeme] = {premiere_planete: create_planet_stats()}
  await interaction.response.send_message(
      f"‚úÖ Nouveau syst√®me **{systeme}** cr√©√© avec la plan√®te **{premiere_planete}** !"
  )
  save_data()


# ----------------- AJOUTER PLANETE -----------------
@tree.command(name="ajout_plan",
              description="Ajouter une plan√®te √† un syst√®me existant",
              guild=guild)
@app_commands.describe(systeme="Nom du syst√®me o√π ajouter la plan√®te",
                       planete="Nom de la nouvelle plan√®te")
@app_commands.autocomplete(systeme=autocomplete_systeme)
async def ajout_plan(interaction: discord.Interaction, systeme: str,
                          planete: str):
  systeme = systeme.capitalize()
  planete = planete.capitalize()

  if systeme not in SYSTEMS:
    await interaction.response.send_message(
        f"‚ùå Le syst√®me **{systeme}** n'existe pas !", ephemeral=True)
    return

  if planete in SYSTEMS[systeme]:
    await interaction.response.send_message(
        f"‚ùå La plan√®te **{planete}** existe d√©j√† dans le syst√®me {systeme} !",
        ephemeral=True)
    return

  SYSTEMS[systeme][planete] = create_planet_stats()
  await interaction.response.send_message(
      f"‚úÖ Plan√®te **{planete}** ajout√©e au syst√®me **{systeme}** !")
  save_data()


# -------- Commande tirage au sort d'honneur  --------
@tree.command(
    name="honneur",
    description="Rechercher des posts contenant au moins un tag parmi les mots-cl√©s donn√©s.",
    guild=guild
)
@app_commands.describe(
    mot1="Mot-cl√© obligatoire",
    mot2="Mot-cl√© optionnel",
    mot3="Mot-cl√© optionnel",
    mot4="Mot-cl√© optionnel",
    mot5="Mot-cl√© optionnel",
    mot6="Mot-cl√© optionnel"
)
@app_commands.autocomplete(
    mot1=autocomplete_honneur,
    mot2=autocomplete_honneur,
    mot3=autocomplete_honneur,
    mot4=autocomplete_honneur,
    mot5=autocomplete_honneur,
    mot6=autocomplete_honneur
)
async def honneur(
    interaction: discord.Interaction,
    mot1: str,
    mot2: Optional[str] = None,
    mot3: Optional[str] = None,
    mot4: Optional[str] = None,
    mot5: Optional[str] = None,
    mot6: Optional[str] = None
):
    await interaction.response.defer(thinking=True, ephemeral=False)

    keywords = [m.lower() for m in [mot1, mot2, mot3, mot4, mot5, mot6] if m]
    matched_threads = []

    for forum_id in FORUM_IDS:
        forum = bot.get_channel(forum_id)
        if not forum:
            print(f"‚ö†Ô∏è Forum introuvable : {forum_id}")
            continue

        try:
            active_threads = list(forum.threads)

            archived_threads = []
            async for t in forum.archived_threads(limit=None):
                archived_threads.append(t)

            threads = active_threads + archived_threads

            for thread in threads:
                if not thread.applied_tags:
                    continue

                tag_names = [tag.name.lower() for tag in thread.applied_tags]
                if any(k in tag_names for k in keywords):
                    matched_threads.append(thread)

        except Exception as e:
            print(f"‚ö†Ô∏è Erreur lors de la lecture du forum {forum_id}: {e}")

    # V√©rifie le nombre de threads trouv√©s
    if len(matched_threads) < 3:
        await interaction.followup.send(
            "‚ö†Ô∏è Moins de 3 honneurs trouv√©s, veuillez v√©rifier les tableaux d'honneur ou bien contacter un admin."
        )
        return

    # Tire un thread au hasard
    chosen_thread = random.choice(matched_threads)
    thread_url = f"https://discord.com/channels/{interaction.guild_id}/{chosen_thread.id}"

    # Cr√©e l‚Äôembed de r√©sultat
    embed = discord.Embed(
        title=f"üéñÔ∏è Honneur s√©lectionn√© au hasard parmi {len(matched_threads)} r√©sultats",
        color=discord.Color.gold()
    )
    embed.add_field(name="Nom du post", value=chosen_thread.name, inline=False)
    embed.add_field(name="Lien", value=f"[Ouvrir le post]({thread_url})", inline=False)

    # Affiche les tags du thread s‚Äôils existent
    if chosen_thread.applied_tags:
        tags_str = ", ".join(tag.name for tag in chosen_thread.applied_tags)
        embed.add_field(name="Tags", value=tags_str, inline=False)

    await interaction.followup.send(embed=embed)

# ----------------- maj honneur tags -----------------
@tree.command(
    name="maj_honneurs",
    description="Met √† jour la liste HonneurKeyWords dans data.json √† partir des tags pr√©sents dans les forums.",
    guild=guild
)
async def maj_honneurs(interaction: discord.Interaction):
    await interaction.response.defer(thinking=True)

    all_tags = set()

    for forum_id in FORUM_IDS:
        forum = bot.get_channel(forum_id)
        if not forum:
            print(f"‚ö†Ô∏è Forum introuvable : {forum_id}")
            continue

        try:
            for tag in forum.available_tags:
                all_tags.add(tag.name)
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur forum {forum_id} : {e}")

    if not all_tags:
        await interaction.followup.send("‚ùå Aucun tag trouv√© dans les forums configur√©s.")
        return

    global HonneurKeyWords
    HonneurKeyWords = sorted(list(all_tags))
    save_data()

    await interaction.followup.send(
        f"‚úÖ Liste des Honneurs mise √† jour avec {len(HonneurKeyWords)} tags :\n"
        f"```{', '.join(HonneurKeyWords)}```"
    )

# ----------------- HELP -----------------
@tree.command(name="h",
              description="Afficher la liste compl√®te des commandes disponibles",
              guild=guild)
async def h(interaction: discord.Interaction):
    embed = discord.Embed(
        title="üìò Commandes disponibles du Bot Galactique",
        description="Voici la liste des commandes class√©es par cat√©gorie :",
        color=discord.Color.blurple()
    )

    # --- Phase & Batailles ---
    embed.add_field(
        name="‚öîÔ∏è Gestion des batailles",
        value=(
            "‚Ä¢ **/ajout** ‚Äî Ajouter une partie ou bataille.\n"
            "‚Ä¢ **/cloture** ‚Äî Cl√¥turer la phase en cours et passer √† la suivante.\n"
            "‚Ä¢ **/phase** ‚Äî Afficher la phase en cours.\n"
            "‚Ä¢ **/phase_stats** ‚Äî Voir les statistiques d‚Äôune phase pr√©c√©dente."
        ),
        inline=False
    )

    # --- Statistiques ---
    embed.add_field(
        name="üìä Statistiques",
        value=(
            "‚Ä¢ **/planete** ‚Äî Afficher les stats d√©taill√©es d‚Äôune plan√®te.\n"
            "‚Ä¢ **/systeme** ‚Äî Afficher les stats de toutes les plan√®tes d‚Äôun syst√®me.\n"
            "‚Ä¢ **/stats** ‚Äî Afficher les stats de toutes les plan√®tes de tous les syst√®mes.\n"
            "‚Ä¢ **/factions** ‚Äî Voir les totaux des batailles et choix de plan√®te par faction."
        ),
        inline=False
    )

    # --- Gestion manuelle ---
    embed.add_field(
        name="üõ†Ô∏è Gestion et modifications",
        value=(
            "‚Ä¢ **/modif** ‚Äî Modifier manuellement les points ou batailles d‚Äôune faction.\n"
            "‚Ä¢ **/ajout_sys** ‚Äî Cr√©er un nouveau syst√®me avec une plan√®te initiale.\n"
            "‚Ä¢ **/ajout_plan** ‚Äî Ajouter une plan√®te dans un syst√®me existant.\n"
            "‚Ä¢ **/liste_sys** ‚Äî Liste tous les syst√®mes et leurs plan√®tes."
        ),
        inline=False
    )

    # --- Honneurs ---
    embed.add_field(
        name="üèÖ Tableau d'Honneur",
        value=(
            "‚Ä¢ **/honneur** ‚Äî Tire au hasard un post d'honneur parmi les mots-cl√©s donn√©s.\n"
            "‚Ä¢ **/maj_honneurs** ‚Äî Met √† jour la liste des mots-cl√©s d‚Äôhonneur √† partir des tags des forums."
        ),
        inline=False
    )

    # --- Aide ---
    embed.add_field(
        name="‚ÑπÔ∏è Divers",
        value="‚Ä¢ **/h** ‚Äî Afficher cette liste de commandes.",
        inline=False
    )

    embed.set_footer(
        text="Bot d√©velopp√© pour la campagne galactique ‚öôÔ∏è",
        icon_url="https://cdn-icons-png.flaticon.com/512/4712/4712109.png"
    )

    await interaction.response.send_message(embed=embed)

# ----------------- EVENT -----------------
@bot.event
async def on_ready():
    print(f"‚úÖ Connect√© en tant que {bot.user}")

    # Synchroniser les commandes pour le serveur
    try:
        guild_obj = discord.Object(id=GUILD_ID)
        await bot.tree.sync(guild=guild_obj)
        print(f"üåç Slash commands synchronis√©es sur le serveur {GUILD_ID}")
    except Exception as e:
        print(f"‚ùå Erreur lors de la synchronisation des commandes : {e}")


# ----------------- RUN BOT -----------------
token = os.getenv("DISCORD_BOT_TOKEN")
if not token:
    print("‚ùå DISCORD_BOT_TOKEN not found in environment variables!")
    exit(1)

load_data()
start_data_watch(DATA_FILE, load_data) #d√©marrage de la surveillance
bot.run(token)
